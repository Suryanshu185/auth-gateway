// Copyright Â© 2025 Prabhjot Singh Sethi, All Rights reserved
// Author: Prabhjot Singh Sethi <prabhjot.sethi@gmail.com>

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.21.12
// source: tenant-user.proto

package api

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	TenantUser_GetUsers_FullMethodName                    = "/api.TenantUser/GetUsers"
	TenantUser_CreateUser_FullMethodName                  = "/api.TenantUser/CreateUser"
	TenantUser_GetUser_FullMethodName                     = "/api.TenantUser/GetUser"
	TenantUser_EnableUser_FullMethodName                  = "/api.TenantUser/EnableUser"
	TenantUser_DisableUser_FullMethodName                 = "/api.TenantUser/DisableUser"
	TenantUser_UpdateUser_FullMethodName                  = "/api.TenantUser/UpdateUser"
	TenantUser_DeleteUser_FullMethodName                  = "/api.TenantUser/DeleteUser"
	TenantUser_ListUserSessions_FullMethodName            = "/api.TenantUser/ListUserSessions"
	TenantUser_LogoutUserSession_FullMethodName           = "/api.TenantUser/LogoutUserSession"
	TenantUser_ListTenantOrgUnitsWithRoles_FullMethodName = "/api.TenantUser/ListTenantOrgUnitsWithRoles"
)

// TenantUserClient is the client API for TenantUser service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Service provided to manage users in Tenants
type TenantUserClient interface {
	// Get List of existing users in a tenant
	GetUsers(ctx context.Context, in *TenantUsersListReq, opts ...grpc.CallOption) (*TenantUsersListResp, error)
	// Create a new user for the given tenant
	CreateUser(ctx context.Context, in *TenantUserCreateReq, opts ...grpc.CallOption) (*TenantUserCreateResp, error)
	// Get an existing user for the given tenant
	GetUser(ctx context.Context, in *TenantUserGetReq, opts ...grpc.CallOption) (*TenantUserGetResp, error)
	// Enable an existing disabled user for the given tenant
	EnableUser(ctx context.Context, in *TenantUserEnableReq, opts ...grpc.CallOption) (*TenantUserEnableResp, error)
	// Disable an existing enabled user for the given tenant
	DisableUser(ctx context.Context, in *TenantUserDisableReq, opts ...grpc.CallOption) (*TenantUserDisableResp, error)
	// Update an existing user for the given tenant
	UpdateUser(ctx context.Context, in *TenantUserUpdateReq, opts ...grpc.CallOption) (*TenantUserUpdateResp, error)
	// Delete an existing user for the given tenant
	DeleteUser(ctx context.Context, in *TenantUserDeleteReq, opts ...grpc.CallOption) (*TenantUserDeleteResp, error)
	// List Active sessions, filter by user if provided
	ListUserSessions(ctx context.Context, in *TenantUserSessionsListReq, opts ...grpc.CallOption) (*TenantUserSessionsListResp, error)
	// logout user from specific session or all sessions
	LogoutUserSession(ctx context.Context, in *TenantUserSessionLogoutReq, opts ...grpc.CallOption) (*TenantUserSessionLogoutResp, error)
	// List org units where a specific user has roles (ops admin cross-tenant access)
	ListTenantOrgUnitsWithRoles(ctx context.Context, in *TenantOrgUnitsWithRolesListReq, opts ...grpc.CallOption) (*TenantOrgUnitsWithRolesListResp, error)
}

type tenantUserClient struct {
	cc grpc.ClientConnInterface
}

func NewTenantUserClient(cc grpc.ClientConnInterface) TenantUserClient {
	return &tenantUserClient{cc}
}

func (c *tenantUserClient) GetUsers(ctx context.Context, in *TenantUsersListReq, opts ...grpc.CallOption) (*TenantUsersListResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TenantUsersListResp)
	err := c.cc.Invoke(ctx, TenantUser_GetUsers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantUserClient) CreateUser(ctx context.Context, in *TenantUserCreateReq, opts ...grpc.CallOption) (*TenantUserCreateResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TenantUserCreateResp)
	err := c.cc.Invoke(ctx, TenantUser_CreateUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantUserClient) GetUser(ctx context.Context, in *TenantUserGetReq, opts ...grpc.CallOption) (*TenantUserGetResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TenantUserGetResp)
	err := c.cc.Invoke(ctx, TenantUser_GetUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantUserClient) EnableUser(ctx context.Context, in *TenantUserEnableReq, opts ...grpc.CallOption) (*TenantUserEnableResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TenantUserEnableResp)
	err := c.cc.Invoke(ctx, TenantUser_EnableUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantUserClient) DisableUser(ctx context.Context, in *TenantUserDisableReq, opts ...grpc.CallOption) (*TenantUserDisableResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TenantUserDisableResp)
	err := c.cc.Invoke(ctx, TenantUser_DisableUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantUserClient) UpdateUser(ctx context.Context, in *TenantUserUpdateReq, opts ...grpc.CallOption) (*TenantUserUpdateResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TenantUserUpdateResp)
	err := c.cc.Invoke(ctx, TenantUser_UpdateUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantUserClient) DeleteUser(ctx context.Context, in *TenantUserDeleteReq, opts ...grpc.CallOption) (*TenantUserDeleteResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TenantUserDeleteResp)
	err := c.cc.Invoke(ctx, TenantUser_DeleteUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantUserClient) ListUserSessions(ctx context.Context, in *TenantUserSessionsListReq, opts ...grpc.CallOption) (*TenantUserSessionsListResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TenantUserSessionsListResp)
	err := c.cc.Invoke(ctx, TenantUser_ListUserSessions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantUserClient) LogoutUserSession(ctx context.Context, in *TenantUserSessionLogoutReq, opts ...grpc.CallOption) (*TenantUserSessionLogoutResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TenantUserSessionLogoutResp)
	err := c.cc.Invoke(ctx, TenantUser_LogoutUserSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantUserClient) ListTenantOrgUnitsWithRoles(ctx context.Context, in *TenantOrgUnitsWithRolesListReq, opts ...grpc.CallOption) (*TenantOrgUnitsWithRolesListResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TenantOrgUnitsWithRolesListResp)
	err := c.cc.Invoke(ctx, TenantUser_ListTenantOrgUnitsWithRoles_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TenantUserServer is the server API for TenantUser service.
// All implementations must embed UnimplementedTenantUserServer
// for forward compatibility.
//
// Service provided to manage users in Tenants
type TenantUserServer interface {
	// Get List of existing users in a tenant
	GetUsers(context.Context, *TenantUsersListReq) (*TenantUsersListResp, error)
	// Create a new user for the given tenant
	CreateUser(context.Context, *TenantUserCreateReq) (*TenantUserCreateResp, error)
	// Get an existing user for the given tenant
	GetUser(context.Context, *TenantUserGetReq) (*TenantUserGetResp, error)
	// Enable an existing disabled user for the given tenant
	EnableUser(context.Context, *TenantUserEnableReq) (*TenantUserEnableResp, error)
	// Disable an existing enabled user for the given tenant
	DisableUser(context.Context, *TenantUserDisableReq) (*TenantUserDisableResp, error)
	// Update an existing user for the given tenant
	UpdateUser(context.Context, *TenantUserUpdateReq) (*TenantUserUpdateResp, error)
	// Delete an existing user for the given tenant
	DeleteUser(context.Context, *TenantUserDeleteReq) (*TenantUserDeleteResp, error)
	// List Active sessions, filter by user if provided
	ListUserSessions(context.Context, *TenantUserSessionsListReq) (*TenantUserSessionsListResp, error)
	// logout user from specific session or all sessions
	LogoutUserSession(context.Context, *TenantUserSessionLogoutReq) (*TenantUserSessionLogoutResp, error)
	// List org units where a specific user has roles (ops admin cross-tenant access)
	ListTenantOrgUnitsWithRoles(context.Context, *TenantOrgUnitsWithRolesListReq) (*TenantOrgUnitsWithRolesListResp, error)
	mustEmbedUnimplementedTenantUserServer()
}

// UnimplementedTenantUserServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTenantUserServer struct{}

func (UnimplementedTenantUserServer) GetUsers(context.Context, *TenantUsersListReq) (*TenantUsersListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUsers not implemented")
}
func (UnimplementedTenantUserServer) CreateUser(context.Context, *TenantUserCreateReq) (*TenantUserCreateResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateUser not implemented")
}
func (UnimplementedTenantUserServer) GetUser(context.Context, *TenantUserGetReq) (*TenantUserGetResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUser not implemented")
}
func (UnimplementedTenantUserServer) EnableUser(context.Context, *TenantUserEnableReq) (*TenantUserEnableResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnableUser not implemented")
}
func (UnimplementedTenantUserServer) DisableUser(context.Context, *TenantUserDisableReq) (*TenantUserDisableResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisableUser not implemented")
}
func (UnimplementedTenantUserServer) UpdateUser(context.Context, *TenantUserUpdateReq) (*TenantUserUpdateResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUser not implemented")
}
func (UnimplementedTenantUserServer) DeleteUser(context.Context, *TenantUserDeleteReq) (*TenantUserDeleteResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUser not implemented")
}
func (UnimplementedTenantUserServer) ListUserSessions(context.Context, *TenantUserSessionsListReq) (*TenantUserSessionsListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListUserSessions not implemented")
}
func (UnimplementedTenantUserServer) LogoutUserSession(context.Context, *TenantUserSessionLogoutReq) (*TenantUserSessionLogoutResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LogoutUserSession not implemented")
}
func (UnimplementedTenantUserServer) ListTenantOrgUnitsWithRoles(context.Context, *TenantOrgUnitsWithRolesListReq) (*TenantOrgUnitsWithRolesListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTenantOrgUnitsWithRoles not implemented")
}
func (UnimplementedTenantUserServer) mustEmbedUnimplementedTenantUserServer() {}
func (UnimplementedTenantUserServer) testEmbeddedByValue()                    {}

// UnsafeTenantUserServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TenantUserServer will
// result in compilation errors.
type UnsafeTenantUserServer interface {
	mustEmbedUnimplementedTenantUserServer()
}

func RegisterTenantUserServer(s grpc.ServiceRegistrar, srv TenantUserServer) {
	// If the following call pancis, it indicates UnimplementedTenantUserServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&TenantUser_ServiceDesc, srv)
}

func _TenantUser_GetUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantUsersListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantUserServer).GetUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantUser_GetUsers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantUserServer).GetUsers(ctx, req.(*TenantUsersListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantUser_CreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantUserCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantUserServer).CreateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantUser_CreateUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantUserServer).CreateUser(ctx, req.(*TenantUserCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantUser_GetUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantUserGetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantUserServer).GetUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantUser_GetUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantUserServer).GetUser(ctx, req.(*TenantUserGetReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantUser_EnableUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantUserEnableReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantUserServer).EnableUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantUser_EnableUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantUserServer).EnableUser(ctx, req.(*TenantUserEnableReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantUser_DisableUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantUserDisableReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantUserServer).DisableUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantUser_DisableUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantUserServer).DisableUser(ctx, req.(*TenantUserDisableReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantUser_UpdateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantUserUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantUserServer).UpdateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantUser_UpdateUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantUserServer).UpdateUser(ctx, req.(*TenantUserUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantUser_DeleteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantUserDeleteReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantUserServer).DeleteUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantUser_DeleteUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantUserServer).DeleteUser(ctx, req.(*TenantUserDeleteReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantUser_ListUserSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantUserSessionsListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantUserServer).ListUserSessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantUser_ListUserSessions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantUserServer).ListUserSessions(ctx, req.(*TenantUserSessionsListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantUser_LogoutUserSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantUserSessionLogoutReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantUserServer).LogoutUserSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantUser_LogoutUserSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantUserServer).LogoutUserSession(ctx, req.(*TenantUserSessionLogoutReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantUser_ListTenantOrgUnitsWithRoles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantOrgUnitsWithRolesListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantUserServer).ListTenantOrgUnitsWithRoles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantUser_ListTenantOrgUnitsWithRoles_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantUserServer).ListTenantOrgUnitsWithRoles(ctx, req.(*TenantOrgUnitsWithRolesListReq))
	}
	return interceptor(ctx, in, info, handler)
}

// TenantUser_ServiceDesc is the grpc.ServiceDesc for TenantUser service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TenantUser_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.TenantUser",
	HandlerType: (*TenantUserServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetUsers",
			Handler:    _TenantUser_GetUsers_Handler,
		},
		{
			MethodName: "CreateUser",
			Handler:    _TenantUser_CreateUser_Handler,
		},
		{
			MethodName: "GetUser",
			Handler:    _TenantUser_GetUser_Handler,
		},
		{
			MethodName: "EnableUser",
			Handler:    _TenantUser_EnableUser_Handler,
		},
		{
			MethodName: "DisableUser",
			Handler:    _TenantUser_DisableUser_Handler,
		},
		{
			MethodName: "UpdateUser",
			Handler:    _TenantUser_UpdateUser_Handler,
		},
		{
			MethodName: "DeleteUser",
			Handler:    _TenantUser_DeleteUser_Handler,
		},
		{
			MethodName: "ListUserSessions",
			Handler:    _TenantUser_ListUserSessions_Handler,
		},
		{
			MethodName: "LogoutUserSession",
			Handler:    _TenantUser_LogoutUserSession_Handler,
		},
		{
			MethodName: "ListTenantOrgUnitsWithRoles",
			Handler:    _TenantUser_ListTenantOrgUnitsWithRoles_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "tenant-user.proto",
}
